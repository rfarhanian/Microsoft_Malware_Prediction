import gc
import time
import warnings
from typing import Type

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, OneHotEncoder

from ClassificationOutput import ClassificationOutput

warnings.filterwarnings('ignore')
plt.style.use('seaborn')

from sklearn.model_selection import KFold

np.random.seed(401)
gc.collect()

def reduce_mem_usage(df, verbose=True):
    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']
    start_mem = df.memory_usage().sum() / 1024 ** 2
    for col in df.columns:
        col_type = df[col].dtypes
        if col_type in numerics:
            c_min = df[col].min()
            c_max = df[col].max()
            if str(col_type)[:3] == 'int':
                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:
                    df[col] = df[col].astype(np.int8)
                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:
                    df[col] = df[col].astype(np.int16)
                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:
                    df[col] = df[col].astype(np.int32)
                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:
                    df[col] = df[col].astype(np.int64)
            else:
                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:
                    df[col] = df[col].astype(np.float16)
                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:
                    df[col] = df[col].astype(np.float32)
                else:
                    df[col] = df[col].astype(np.float64)
    end_mem = df.memory_usage().sum() / 1024 ** 2
    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (
            start_mem - end_mem) / start_mem))
    return df


def fill_with_most_frequent_value(df):
    '''
    Can be improved with Imputer later.
    '''
    x = df.value_counts().argmax()
    df.fillna(x, inplace=True)


dtypes = {
    'MachineIdentifier': 'category',  # Individual machine ID
    'ProductName': 'category',  # Defender state information e.g. win8defender
    'EngineVersion': 'category',  # Defender state information e.g. 1.1.12603.0
    'AppVersion': 'category',  # Defender state information e.g. 4.9.10586.0
    'AvSigVersion': 'category',  # Defender state information e.g. 1.217.1014.0
    'IsBeta': 'int8',  # - Defender state information e.g. false
    'RtpStateBitfield': 'float16',
    'IsSxsPassiveMode': 'int8',
    'DefaultBrowsersIdentifier': 'float16',  # ID for the machine's default browser
    'AVProductStatesIdentifier': 'float32',  # ID for the specific configuration of a user's antivirus software
    'AVProductsInstalled': 'float16',
    'AVProductsEnabled': 'float16',
    'HasTpm': 'int8',  # True if machine has tpm
    'CountryIdentifier': 'int16',  # ID for the country the machine is located in
    'CityIdentifier': 'float32',  # ID for the city the machine is located in
    'OrganizationIdentifier': 'float16',
    # ID for the organization the machine belongs in, organization ID is mapped to both specific companies and broad industries
    'GeoNameIdentifier': 'float16',  # ID for the geographic region a machine is located in
    'LocaleEnglishNameIdentifier': 'int8',  # English name of Locale ID of the current user
    'Platform': 'category',  # Calculates platform name (of OS related properties and processor property)
    'Processor': 'category',  # This is the process architecture of the installed operating system
    'OsVer': 'category',  # Version of the current operating system
    'OsBuild': 'int16',  # Build of the current operating system
    'OsSuite': 'int16',  # Product suite mask for the current operating system
    'OsPlatformSubRelease': 'category',
    # Returns the OS Platform sub-release (Windows Vista, Windows 7, Windows 8, TH1, TH2, Windows 10)
    'OsBuildLab': 'category',
    # Build lab that generated the current OS. Example: 9600.17630.amd64fre.winblue_r7.150109-2022
    'SkuEdition': 'category',
    # The goal of this feature is to use the Product Type defined in the MSDN to map to a 'SKU-Edition' name that is useful in population reporting. The valid Product Type are defined in %sdxroot%\data\windowseditions.xml. This API has been used since Vista and Server 2008, so there are many Product Types that do not apply to Windows 10. The 'SKU-Edition' is a string value that is in one of three classes of results. The design must hand each class.
    'IsProtected': 'float16',
    # This is a calculated field derived from the Spynet Report's AV Products field. Returns: a. TRUE if there is at least one active and up-to-date antivirus product running on this machine. b. FALSE if there is no active AV product on this machine, or if the AV is active, but is not receiving the latest updates. c. null if there are no Anti Virus Products in the report. Returns: Whether a machine is protected.
    'AutoSampleOptIn': 'int8',
    # This is the SubmitSamplesConsent value passed in from the service, available on CAMP 9+
    'PuaMode': 'category',  # Pua Enabled mode from the service
    'SMode': 'float16',
    # This field is set to true when the device is known to be in 'S Mode', as in, Windows 10 S mode, where only Microsoft Store apps can be installed
    'IeVerIdentifier': 'float16',
    'SmartScreen': 'category',
    # This is the SmartScreen enabled string value from registry. This is obtained by checking in order, HKLM\SOFTWARE\Policies\Microsoft\Windows\System\SmartScreenEnabled and HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\SmartScreenEnabled. If the value exists but is blank, the value "ExistsNotSet" is sent in telemetry.
    'Firewall': 'float16',
    # This attribute is true (1) for Windows 8.1 and above if windows firewall is enabled, as reported by the service.
    'UacLuaenable': 'float32',
    # This attribute reports whether or not the "administrator in Admin Approval Mode" user type is disabled or enabled in UAC. The value reported is obtained by reading the regkey HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\EnableLUA.
    'Census_MDC2FormFactor': 'category',
    # A grouping based on a combination of Device Census level hardware characteristics. The logic used to define Form Factor is rooted in business and industry standards and aligns with how people think about their device. (Examples: Smartphone, Small Tablet, All in One, Convertible...)
    'Census_DeviceFamily': 'category',
    # AKA DeviceClass. Indicates the type of device that an edition of the OS is intended for. Example values: Windows.Desktop, Windows.Mobile, and iOS.Phone
    'Census_OEMNameIdentifier': 'float16',
    'Census_OEMModelIdentifier': 'float32',
    'Census_ProcessorCoreCount': 'float16',  # Number of logical cores in the processor
    'Census_ProcessorManufacturerIdentifier': 'float16',
    'Census_ProcessorModelIdentifier': 'float16',
    'Census_ProcessorClass': 'category',
    # A classification of processors into high/medium/low. Initially used for Pricing Level SKU. No longer maintained and updated
    'Census_PrimaryDiskTotalCapacity': 'float32',  # Amount of disk space on primary disk of the machine in MB
    'Census_PrimaryDiskTypeName': 'category',  # Friendly name of Primary Disk Type - HDD or SSD
    'Census_SystemVolumeTotalCapacity': 'float32',
    # The size of the partition that the System volume is installed on in MB
    'Census_HasOpticalDiskDrive': 'int8',  # True indicates that the machine has an optical disk drive (CD/DVD)
    'Census_TotalPhysicalRAM': 'float32',  # Retrieves the physical RAM in MB
    'Census_ChassisTypeName': 'category',
    # Retrieves a numeric representation of what type of chassis the machine has. A value of 0 means xx
    'Census_InternalPrimaryDiagonalDisplaySizeInInches': 'float16',
    # Retrieves the physical diagonal length in inches of the primary display
    'Census_InternalPrimaryDisplayResolutionHorizontal': 'float16',
    # Retrieves the number of pixels in the horizontal direction of the internal display.
    'Census_InternalPrimaryDisplayResolutionVertical': 'float16',
    # Retrieves the number of pixels in the vertical direction of the internal display
    'Census_PowerPlatformRoleName': 'category',
    # Indicates the OEM preferred power management profile. This value helps identify the basic form factor of the device
    'Census_InternalBatteryType': 'category',
    'Census_InternalBatteryNumberOfCharges': 'float32',
    'Census_OSVersion': 'category',  # Numeric OS version Example - 10.0.10130.0
    'Census_OSArchitecture': 'category',
    # Architecture on which the OS is based. Derived from OSVersionFull. Example - amd64
    'Census_OSBranch': 'category',
    # Branch of the OS extracted from the OsVersionFull. Example - OsBranch = fbl_partner_eeap where OsVersion = 6.4.9813.0.amd64fre.fbl_partner_eeap.140810-0005
    'Census_OSBuildNumber': 'int16',
    # OS Build number extracted from the OsVersionFull. Example - OsBuildNumber = 10512 or 10240
    'Census_OSBuildRevision': 'int32',
    # OS Build revision extracted from the OsVersionFull. Example - OsBuildRevision = 1000 or 16458
    'Census_OSEdition': 'category',
    # Edition of the current OS. Sourced from HKLM\Software\Microsoft\Windows NT\CurrentVersion@EditionID in registry. Example: Enterprise
    'Census_OSSkuName': 'category',  # OS edition friendly name (currently Windows only)
    'Census_OSInstallTypeName': 'category',  # Friendly description of what install was used on the machine i.e. clean
    'Census_OSInstallLanguageIdentifier': 'float16',
    'Census_OSUILocaleIdentifier': 'int16',
    'Census_OSWUAutoUpdateOptionsName': 'category',
    # Friendly name of the WindowsUpdate auto-update settings on the machine.
    'Census_IsPortableOperatingSystem': 'int8',
    # Indicates whether OS is booted up and running via Windows-To-Go on a USB stick.
    'Census_GenuineStateName': 'category',  # Friendly name of OSGenuineStateID. 0 = Genuine
    'Census_ActivationChannel': 'category',  # Retail license key or Volume license key for a machine.
    'Census_IsFlightingInternal': 'float16',
    'Census_IsFlightsDisabled': 'float16',  # Indicates if the machine is participating in flighting.
    'Census_FlightRing': 'category',
    # The ring that the device user would like to receive flights for. This might be different from the ring of the OS which is currently installed if the user changes the ring after getting a flight from a different ring.
    'Census_ThresholdOptIn': 'float16',
    'Census_FirmwareManufacturerIdentifier': 'float16',
    'Census_FirmwareVersionIdentifier': 'float32',
    'Census_IsSecureBootEnabled': 'int8',  # Indicates if Secure Boot mode is enabled.
    'Census_IsWIMBootEnabled': 'float16',
    'Census_IsVirtualDevice': 'float16',  # Identifies a Virtual Machine (machine learning model)
    'Census_IsTouchEnabled': 'int8',  # Is this a touch device ?
    'Census_IsPenCapable': 'int8',  # Is the device capable of pen input ?
    'Census_IsAlwaysOnAlwaysConnectedCapable': 'float16',
    # Retreives information about whether the battery enables the device to be AlwaysOnAlwaysConnected
    'Wdft_IsGamer': 'float16',
    # Indicates whether the device is a gamer device or not based on its hardware combination.
    'Wdft_RegionIdentifier': 'float16',
    'HasDetections': 'int8'
}

numerics = ['int8', 'int16', 'int32', 'int64', 'float16', 'float32', 'float64']
numerical_columns = [c for c, v in dtypes.items() if v in numerics]
categorical_columns = [c for c, v in dtypes.items() if v not in numerics]
gc.collect()

# nrows = 7853253
nrows = 100000
# _______________________________________________________________________________
retained_columns = numerical_columns + categorical_columns
train = pd.read_csv('./input/train.csv',
                    nrows=nrows,
                    usecols=retained_columns,
                    dtype=dtypes)
# _______________________________________________________________
retained_columns += ['MachineIdentifier']
retained_columns.remove('HasDetections')
test = pd.read_csv('./input/test.csv',
                   nrows=nrows,
                   usecols=retained_columns,
                   dtype=dtypes)
gc.collect()

true_numerical_columns = [
    'Census_ProcessorCoreCount',
    'Census_PrimaryDiskTotalCapacity',
    'Census_SystemVolumeTotalCapacity',
    'Census_TotalPhysicalRAM',
    'Census_InternalPrimaryDiagonalDisplaySizeInInches',
    'Census_InternalPrimaryDisplayResolutionHorizontal',
    'Census_InternalPrimaryDisplayResolutionVertical',
    'Census_InternalBatteryNumberOfCharges'
]
gc.collect()

dropping_cols = [
    'MachineIdentifier', 'EngineVersion', 'AppVersion', 'OsVer', 'OsBuildLab', 'AvSigVersion', 'SmartScreen',
    'Census_InternalBatteryType', 'Census_ProcessorClass', 'Census_ChassisTypeName', 'Census_OSEdition',
    'Census_OSSkuName', 'Census_OSVersion', 'Census_OSBranch',
]

col_with_too_many_null_values = [
    'Census_IsFlightingInternal', 'Census_ThresholdOptIn', 'Census_IsWIMBootEnabled',
    'DefaultBrowsersIdentifier', 'OrganizationIdentifier', 'PuaMode'
]

dropping_cols.extend(col_with_too_many_null_values)

print('isNull:', train.isnull().sum())
train.isnull().sum()

train_cols_with_missing_values = ['AVProductStatesIdentifier', 'AVProductsInstalled', 'Census_PrimaryDiskTypeName',
                                  'Census_PrimaryDiskTypeName', 'AVProductsEnabled', 'Census_FirmwareVersionIdentifier',
                                  'Firewall', 'Census_PrimaryDiskTypeName', 'Census_FirmwareManufacturerIdentifier',
                                  'Census_PowerPlatformRoleName', 'Census_PowerPlatformRoleName', 'IsProtected',
                                  'IsProtected', 'SMode', 'UacLuaenable', 'Census_ProcessorCoreCount',
                                  'Census_PrimaryDiskTotalCapacity', 'Census_SystemVolumeTotalCapacity',
                                  'Census_SystemVolumeTotalCapacity', 'Census_TotalPhysicalRAM',
                                  'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                                  'Census_InternalPrimaryDisplayResolutionHorizontal',
                                  'Census_InternalPrimaryDisplayResolutionVertical',
                                  'Census_InternalBatteryNumberOfCharges', 'Census_IsVirtualDevice',
                                  'Census_IsAlwaysOnAlwaysConnectedCapable', 'Wdft_IsGamer',
                                  'Census_OSInstallLanguageIdentifier', 'Census_IsFlightingInternal',
                                  'Census_IsFlightsDisabled', 'Census_ThresholdOptIn',
                                  'Census_FirmwareManufacturerIdentifier', 'RtpStateBitfield', 'CityIdentifier',
                                  'GeoNameIdentifier', 'OsBuildLab'
                                  ]

test_cols_with_missing_values = ['IeVerIdentifier', 'Census_OEMNameIdentifier', 'Census_OEMModelIdentifier',
                                 'Census_ProcessorManufacturerIdentifier', 'RtpStateBitfield',
                                 'AVProductStatesIdentifier', 'AVProductsInstalled', 'AVProductsEnabled',
                                 'CityIdentifier', 'GeoNameIdentifier', 'IsProtected', 'SMode', 'Firewall',
                                 'UacLuaenable', 'Census_ProcessorCoreCount', 'Census_PrimaryDiskTypeName',
                                 'Census_SystemVolumeTotalCapacity', 'Census_TotalPhysicalRAM',
                                 'Census_InternalPrimaryDiagonalDisplaySizeInInches',
                                 'Census_InternalPrimaryDisplayResolutionHorizontal',
                                 'Census_InternalPrimaryDisplayResolutionVertical',
                                 'Census_InternalBatteryNumberOfCharges', 'Census_OSInstallLanguageIdentifier',
                                 'Census_IsFlightsDisabled', 'Census_FirmwareManufacturerIdentifier',
                                 'Census_FirmwareVersionIdentifier', 'Census_IsVirtualDevice',
                                 'Census_IsAlwaysOnAlwaysConnectedCapable', 'Wdft_IsGamer', 'Wdft_RegionIdentifier',
                                 'Census_PrimaryDiskTotalCapacity']

for col in test_cols_with_missing_values:
    fill_with_most_frequent_value(test[col])

for col in train_cols_with_missing_values:
    fill_with_most_frequent_value(train[col])

print('train isNull :', train.isnull().sum())
for dropping_column in dropping_cols:
    train.drop(dropping_column, axis=1, inplace=True)
    test.drop(dropping_column, axis=1, inplace=True)

binary_variables = [c for c in train.columns if train[c].nunique() == 2]

categorical_columns = [c for c in train.columns if (c not in true_numerical_columns) & (c not in binary_variables)]
test_categorical_columns = [c for c in test.columns if (c not in true_numerical_columns) & (c not in binary_variables)]
test['Census_MDC2FormFactor'].replace('Other', 'IoTOther', inplace=True)
test['Census_GenuineStateName'].fillna('IS_GENUINE', inplace=True)
test['Census_FlightRing'].replace('CBCanary', 'Canary', inplace=True)
gc.collect()

train = reduce_mem_usage(train)
test = reduce_mem_usage(test)


# del train['HasDetections']
gc.collect()

train_columns = train.columns
if nrows < 2000000:
    categorical_columns.append('ProductName')
    categorical_columns.append('Census_DeviceFamily')
    test_categorical_columns.append('ProductName')
    test_categorical_columns.append('Census_DeviceFamily')

categorical_columns = [c for c in categorical_columns if c not in ['MachineIdentifier']]
features = [c for c in train.columns if c not in ['MachineIdentifier']]
feature_index_map = dict()
for idx, val in enumerate(train_columns):
    feature_index_map[val] = idx

categorical_feature_rank = []
for categorical_column in categorical_columns:
    categorical_feature_rank.append(feature_index_map[categorical_column])

print(categorical_feature_rank)

test_feature_index_map = dict()
for idx, val in enumerate(test.columns):
    test_feature_index_map[val] = idx

test_categorical_feature_rank = []
for ca in test_categorical_columns:
    test_categorical_feature_rank.append(test_feature_index_map[ca])

print('test_categorical_feature_rank:', test_categorical_feature_rank)

gc.collect()

start = time.time()
for categorical_col in categorical_columns:
    label_encoder = LabelEncoder()
    print('>>>>>>>label encoding train categorical column: ', categorical_col)
    train[categorical_col] = label_encoder.fit_transform(train[categorical_col])
    print('>>>>>>>label encoding train categorical column finished for ', categorical_col)

end = time.time()
gc.collect()
delta = end - start
print('it took ', str(delta), 'seconds to label encode categorical columns of train data')

start = time.time()
for categorical_col in test_categorical_columns:
    print('>>>>>>>label encoding test categorical column: ', categorical_col)
    label_encoder = LabelEncoder()
    test[categorical_col] = label_encoder.fit_transform(test[categorical_col])
    print('>>>>>>>label encoding test categorical column finished for ', categorical_col)

end = time.time()
gc.collect()

delta = end - start
print('it took ', str(delta), 'seconds to label encode categorical columns of test data')

train.info()
reduce_mem_usage(train)
one_hot_encoder = OneHotEncoder(categorical_features=categorical_feature_rank, sparse=False)
nans = lambda df: df[df.isnull().any(axis=1)]
nans(train)
nans(test)

target = train['HasDetections']
del train['HasDetections']
gc.collect()

print('train is not fit transformed yet')
train_encoded = one_hot_encoder.fit_transform(train)
print('train is fit transformed')
print(train)
gc.collect()

print('isNull test:', test.isnull().sum())

one_hot_encoder = OneHotEncoder(categorical_features=test_categorical_feature_rank, sparse=False)
print('test is not fit transformed yet')
test_encoded = one_hot_encoder.fit_transform(test)
print('test is fit transformed')
print(test)
gc.collect()


y = target

X_train, X_test, y_train, y_test = train_test_split(train_encoded, y, test_size=0.2, random_state=0)

data = (X_train, y_train, 5)

classifier = RandomForestClassifier(n_estimators=40, min_samples_leaf=100, max_features=0.5, n_jobs=-1, oob_score=False)
classifier.fit(X_train, y_train)
print(classifier.feature_importances_)

cm = confusion_matrix(y_test, classifier.predict(X_test))
print(cm)
print('confusion matrix printed')


def run(a_clf: Type, data, clf_hyper={}):
    M, L, n_folds = data  # unpack data container
    kf = KFold(n_splits=n_folds)  # Establish the cross validation
    ret = {}  # classic explication of results

    for ids, (train_index, test_index) in enumerate(kf.split(M, L)):
        clf = a_clf(**clf_hyper)  # unpack parameters into clf is they exist

        clf.fit(M[train_index], L[train_index])

        pred = clf.predict(M[test_index])

        ret[ids] = {'clf': clf,
                    'train_index': train_index,
                    'test_index': test_index,
                    'accuracy': accuracy_score(L[test_index], pred),
                    'classificationReport': classification_report(L[test_index], pred)
                    }
    return ret


def run_all(classifiers, data):
    result = []
    for classifier in classifiers:
        classifier_name = classifier.get_name()
        classifier_type = classifier.get_classifier_type()
        attributes = classifier.get_hyper_parameter_attributes().get_attributes()
        response = run(classifier_type, data, attributes)
        result.append(ClassificationOutput(classifier_name, classifier.get_title(), response, attributes))
    return result

# classifiers = Classifiers()
# result = run_all(classifiers.all_classifiers(), data)
# Classifiers.visualize(result, 'Accuracy Of Classifiers', 'classificationResult.png')
# Classifiers.visualize_with_histogram(result)
#
# classifier_dictionary = {'RandomForestClassifier': RandomForestClassifier(),
#                          'LogisticRegression': LogisticRegression(),
#                          'MLPClassifier': MLPClassifier(),
#                          'KNeighborsClassifier': KNeighborsClassifier(),
#                          }
#
# hyperparameter_dictionary = {
#     'RandomForestClassifier': {"min_samples_split": [2, 4], "n_jobs": [-1], "n_estimators": [10, 12, 15]},
#     'LogisticRegression': {"tol": [0.0001], "C": [1, 3, 5], "penalty": ['l1', 'l2'], "dual": [False],
#                            "fit_intercept": [True]},
#     'MLPClassifier': {"activation": ['logistic', 'tanh', 'relu'], "solver": ["lbfgs", "sgd"]},
#     'KNeighborsClassifier': {"algorithm": ['auto', 'kd_tree', 'ball_tree'], "n_neighbors": [5, 6, 7], "n_jobs": [-1],
#                              "leaf_size": [25, 30, 40]}
# }
# gridSearch = MyGridSearch(classifier_dictionary, hyperparameter_dictionary)
# gridSearch.fit(data[0], data[1], scoring='accuracy')
# summary = gridSearch.score_summary(sort_by='max_score')
# print(summary)

# prediction_probability = classifier.predict_proba(test_encoded)
# test['HasDetections'] = prediction_probability[:, -1]
# test_copy = test.loc[:, ['MachineIdentifier', 'HasDetections']]
# test_copy.to_csv('./output/submission.csv', index=False)
